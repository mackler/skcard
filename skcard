#!/bin/sh

# This script takes three arguments: (1) the output directory, (2) English text, (3) Slovak text
# It creates an MP3 flashcard consisting of the English text followed by the Slovak text twice.

# Depends on this site: https://beta.soundoftext.com/
# First we make a POST to https://sound-of-text-3ba84.firebaseapp.com/sounds
# with a JSON payload containing our desired text.  It returns JSON containing a URL path.
# We slam that path onto the end of a GET request to
# https://firebasestorage.googleapis.com/v0/b/sound-of-text-3ba84.appspot.com/o/
# and that returns a JSON object containing the secret token needed to get the audio.

# Configure the languages here:
localvoice=en-US     # American English
foreignvoice=sk-SK   # Slovak

# Define some functions

usage() {
    echo "usage: $1 outputdir local-text foreign-text | -n outputdir local-file foreign-file1 [ foreign-file-2 ]" && exit $2
}

# This function just appends the MP3 filetype to a string to get a filename

add_suffix() {
    echo "$1".mp3
}

# This function removes question marks and periods
normalize() {
    echo $@ | sed 's/?|\.//g'
}

# This function converts text of a language to sound using network services

get_sound() {
    local voice=$1
    local text="$2"
    echo processing $voice text: '"'"${text}"'"'

    # First we hit firebaseapp which will make Google generate a token.
    local payload="{\"text\": \"${text}\", \"voice\": \"${voice}\"}"
    local path="$(curl -H "Content-type: application/json" -d "$payload" https://sound-of-text-3ba84.firebaseapp.com/sounds | sed 's/{"path":"\([^\"]*\)"}/\1/')"
    local urltext=$(echo -n $path | hexdump -v -e '/1 "%02x"' | sed 's/\(..\)/%\1/g')
    echo encoded $voice text $path is $urltext

    # Next we hit GoogleApis.com to get the token
    local token=$(curl https://firebasestorage.googleapis.com/v0/b/sound-of-text-3ba84.appspot.com/o/$urltext |
                grep downloadTokens |
                sed 's/.*downloadTokens": "\([^"]*\)".*/\1/')

    echo the $voice download token is "'""$token""'"

    # Finally, we hit GoogleApis.com again with the token to get the sound:
    local filename=$(add_suffix $voice)
    curl https://firebasestorage.googleapis.com/v0/b/sound-of-text-3ba84.appspot.com/o/${urltext}\?alt=media\&token=${token} > $filename
    echo $filename
}

# PROGRAM EXECUTION STARTS HERE

if [ $# -lt 3 ]; then # not enough arguments passed on script invocation
    usage $0 1
fi

if [ "$1" = -n ]; then  # user is providing existing audio filenames rather than text to convert
    use_local_files=true
    shift
fi

outputdir=$1

if [ ! -d "$outputdir" -o ! -w "$outputdir" ]; then
    echo bad output directory $outputdir && exit 3
fi

# this function removes filename suffix
remove_suffix() {
    echo "$1" | sed s/\.[^.]*$//
}

# At this point we know whether we are using local files or a network service, and we
# know that the output directory exists and is writable.

if [ "$use_local_files" = true ] ; then
    # Use existing sound files specified on the command-line
    echo using local files as input
    localfile="$2"
    echo using local-language file $localfile

    foreignfile1="$3"
    echo using foreign-language file $foreignfile1
    if [ $# -ge 4 ]; then
        foreignfile2="$4"
        echo using second foreign-language file $foreignfile2
    else
        foreignfile2="$foreignfile1"
        echo arg count is $# so using same foreign file twice
    fi
    strippedlocal="$(remove_suffix "$localfile")"
    echo stripped local name is $strippedlocal
    strippedforeign="$(remove_suffix "$foreignfile1")"
    echo stripped foreign name is $strippedforeign
    outputfile="$(add_suffix "$strippedlocal - $strippedforeign")"
else
    # Generate the sound files from command-line specified text
    echo using network service

    # These variables contain the text in each language that will be converted to speech
    localtext=$2
    foreigntext=$3

    get_sound $localvoice "$localtext"
    localfile=$(add_suffix $localvoice)
    get_sound $foreignvoice "$foreigntext"
    foreignfile1=$(add_suffix $foreignvoice)
    foreignfile2=$foreignfile1 # since we repeate the foreign clip

    # Question marks in file names will cause problems.  Remove them before assembling the output filename.
    localtext=$(normalize $localtext)
    foreigntext=$(normalize $foreigntext)
    outputfile="${outputdir}/${localtext} - ${foreigntext}.mp3"
fi

# Now the variables `localfile`, `foreignfile1` and `foreignfile2` contain the
# names of the files with the audio that will go into the final output file, and
# `outputfile` contains the name of the output file.

echo output filename is $outputfile

# Generate the silence files.  The first is as long as the first foreign sound file, the
# second the second.

silencefile1=silence1.mp3
silencefile2=silence2.mp3

# This function takes two arguments: the first is an existing sound file, the
# second a filename into which a silence as long as the existing file will be written.
# Return the duration of a sound file, one second minimum.
write_silence() {
    # TODO, figure out how to invoke ffmpeg only only to get these three parameters
    local duration=$(ffmpeg -hide_banner -i "$1" 2>&1 | grep Duration | awk '{print $2}' | sed s/,//)
    echo duration is $duration
    local sample_rate=$(ffmpeg -hide_banner -i "$1" 2>&1 | grep Stream | awk '{print $5}')
    echo sample rate is $sample_rate
    local channels=$(ffmpeg -hide_banner -i "$1" 2>&1 | grep Stream | awk '{print $7}' | sed s/,//)
    echo channels is $channels
    duration=$(echo $duration | sed 's/00:00:00\.[0-9][0-9]/00:00:01/') # duration must be at least one second
    ffmpeg -hide_banner -f lavfi -i anullsrc=r=${sample_rate}:cl=${channels} -t $duration -b:a 32k -f mp3 - > $2
}

write_silence "$foreignfile1" "$silencefile1"
write_silence "$foreignfile2" "$silencefile2"

# This command generates the actual work-product
ffmpeg -hide_banner -i "concat:${localfile}|${silencefile1}|${foreignfile1}|${silencefile2}|${foreignfile2}|${silencefile2}" \
       -acodec copy "$outputfile" || exit 2

# Delete the input files IFF we generated them from text:

if [ "$use_local_files" != true ]; then
    rm $localfile
    rm $foreignfile1
fi

rm $silencefile1
rm $silencefile2

ls -l "$outputfile"
